//! Bookmarks prevent objects from being automatically deleted from the database.

use samizdat_common::db::{writable_tx, Table as _, WritableTx};
use serde_derive::{Deserialize, Serialize};

use crate::db::{MergeOperation, Table};

use super::ObjectRef;

/// The type of the bookmark, whether induced by the existence of another object or
/// created by the user.
#[derive(Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Serialize, Deserialize)]
pub enum BookmarkType {
    /// A bookmark generated by the dependency from other entities in the database.
    Reference,
    /// A bookmark defined by the user.
    User,
}

/// A bookmark.
#[derive(Debug, Clone)]
pub struct Bookmark {
    /// The bookmark type.
    ty: BookmarkType,
    /// The object that is being prevented from being automatically deleted.
    object: ObjectRef,
}

impl Bookmark {
    /// Creates a new bookmark.
    pub(crate) fn new(ty: BookmarkType, object: ObjectRef) -> Bookmark {
        Bookmark { ty, object }
    }

    /// Generate the key of this bookmark in the database.
    fn key(&self) -> Vec<u8> {
        [
            self.object.hash().as_ref(),
            bincode::serialize(&self.ty)
                .expect("can serialize")
                .as_ref(),
        ]
        .concat()
    }

    /// Gets the number of times this bookmark was created. This only makes sense for
    /// reference bookmarks, which work like reference counting (i.e, `Rc` and `Arc`).
    pub fn get_count(&self) -> Result<i16, crate::Error> {
        let operation: MergeOperation = Table::Bookmarks
            .atomic_get(self.key(), |serialized| bincode::deserialize(serialized))
            .transpose()?
            .unwrap_or_default();

        Ok(operation.eval_on_zero())
    }

    /// Whether this bookmark exists in the database.
    pub fn is_marked(&self) -> Result<bool, crate::Error> {
        Ok(self.get_count()? != 0)
    }

    /// Creates the bookmark in the database using the supplied [`WriteBatch`]. This will
    /// increase the count of reference bookmarks and set the count of user bookmarks to
    /// one.
    pub fn mark_with(&self, tx: &mut WritableTx<'_>) {
        let operation = match self.ty {
            BookmarkType::Reference => MergeOperation::Increment(1),
            BookmarkType::User => MergeOperation::Set(1),
        };

        Table::Bookmarks.map(tx, self.key(), operation.merger());
    }

    /// Creates the bookmark in the database. This will increase the count of reference
    /// bookmarks and set the count of user bookmarks to one.
    pub fn mark(&self) -> Result<(), crate::Error> {
        writable_tx(|tx| {
            self.mark_with(tx);
            Ok(())
        })
    }

    /// Removes the bookmark from the database using the supplied [`WriteBatch`]. This
    /// will decrease the count of reference bookmarks by one (or delete them if the
    /// count goes to zero) and delete user bookmarks.
    pub fn unmark_with(&self, tx: &mut WritableTx<'_>) {
        let operation = match self.ty {
            BookmarkType::Reference => MergeOperation::Increment(-1),
            BookmarkType::User => MergeOperation::Set(0),
        };

        Table::Bookmarks.map(tx, self.key(), operation.merger());
    }

    /// Removes the bookmark from the database. This will decrease the count of
    /// reference bookmarks by one (or delete them if the count goes to zero) and delete
    /// user bookmarks.
    pub fn unmark(&self) -> Result<(), crate::Error> {
        writable_tx(|tx| {
            self.unmark_with(tx);
            Ok(())
        })
    }

    /// Deletes the bookmark from the database using the supplied [`Tx`],
    /// _regardless_ of the reference count.
    pub fn clear_with(&self, tx: &mut WritableTx<'_>) {
        Table::Bookmarks.delete(tx, self.key());
    }
}
